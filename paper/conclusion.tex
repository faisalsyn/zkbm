\section{Conclusions and Future Work}\label{sec:conclusions}
%\note{dummy citations~\cite{Zookeeper, YCSB, ZAB, Rao:2011:UPB:1938545.1938549, activemessages, reactive, cloudsuite, chubby, 93948, paxos, Herlihy:1991:WS:114005.102808}.}
In this paper we investigated synchronization in distributed systems. Specifically, we showed the effect of high connection latency on traditional synchronization primitives for mutual conclusion, namely queues and locks. We leveraged Zookeeper, a distributed coordination protocol, as a framework for our primitives' implementations. We provided an analytical treatment of synchronization latency and invistigated the effect of RTT and latency behavior in broadcast and majority-broadcast systems. Also, we displayed a model for calculating wait times caused by lock contention. Using those components we outline the full latency as a function of building blocks to aid gaining perspective for future research in tackling the problem. The main contribution of this paper is a study of the effect of latency and contention on distributed synchronization. In our study we find out that queue locks are better for high contention scenarios, whereas test-and-set locks are better for low contention, high latency scenarios. We also studied asynchronous implementations of both primitives. Our asynchronous implementation of locks proved to be very efficient and achieved best results for all scenarios compared to other primitives. This of course comes with a cost of added computation and bandwidth utilization.

We are foreseeing two directions that can be taken from this work. First, taking the modling components outlined here and studying them in isolation. Having closed-form expressions for those components will enable us to have a full view of the synchronization process and will aid us in designing new ones, given the contention and network characteristics. Second, given the insights gained and different parts of the RTT and contention spectrum, a reactive protocol can be designed to achieve the best of both primitives. For this, an analysis component must be designed to predict the condition of the system and map the environment to the suitable primitive. Also, a protocol for switching between primitives must be designed to allow for life switching and low overhead.
