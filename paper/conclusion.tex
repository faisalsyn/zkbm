\section{Conclusions and Future Work}\label{sec:conclusions}
%\note{dummy citations~\cite{Zookeeper, YCSB, ZAB, Rao:2011:UPB:1938545.1938549, activemessages, reactive, cloudsuite, chubby, 93948, paxos, Herlihy:1991:WS:114005.102808}.}
In this paper we investigated synchronization in distributed systems. Specifically, we showed the effect of high connection latency on traditional synchronization primitives, namely queue locks, and test-and-set. We laveraged Zookeeper, a distributed coordination protocol, as a framework for our primitives' implementations. We provided an analytical treatment of synchronization latency. In it we invistigated the effect of RTT and latency behavior in broadcast and majority-broadcast systems. Also, we displayed a model for calculating wait times caused by lock contention. Using those components we outline the full latency as a function of building blocks to aid gaining perspective for future research in tackling the problem. The main contribution of this paper is a study of the effect of latency and contention on distributed synchronization. In our study we find out that queue locks are better for high contention scenarios, whereas test-and-set locks are better for low contention, high latency scenarios. We also studied asynchronous implementations of both primitives. Our asynchronous implementation of test-and-set proved to be very efficient and achieved best results for all scenarios compared to other primitives. This of course comes with a cost of added computation and bandwidth utilization for the client.

We are foreseeing two directions that can be taken from this work. First, taking the modling components outlined here and studying them in isolation. Having closed-form expressions for those components will enable us to have a full view of the synchronization process and will aid us in designing new ones, given the contention and network characteristics. Second, derived conclusions on the different behavior of studied primitives ,given different parts of the RTT and contention spectrum, a reactive protocol can be designed to achieve the best of both primitives. For this, an analysis component must be designed to predict the condition of the system and map the environment to the suitable primitive. Also, a protocol for switching between primitives must be designed that achieve low latency for switching and avoid false positives.

